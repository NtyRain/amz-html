<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      #app {
        width: 50%;
        margin: 0 auto;
      }
      h1 {
        font-size: 4rem;
        margin-top: 10rem;
        margin-bottom: 3rem;
      }
      p {
        margin: 5rem 0;
      }
      mark {
        background: transparent;
        color: inherit;
        background-image: linear-gradient(#1e9, #1e8);
        background-repeat: no-repeat;
        background-position: 0 100%;
        background-size: 0 38%;
      }
      mark.animate {
        animation: highlight1 2s ease-in-out forwards;
      }
      @keyframes highlight1 {
        to {
          background-size: 100% 38%;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <h1>窗口观察器 Intersection Observer</h1>
      <p>
        从历史上看，检测元素的可见性或两个元素相对于彼此的相对可见性一直是一项艰巨的任务，其解决方案不可靠并且容易导致浏览器和用户访问的站点变得缓慢。<mark
          >随着网络的成熟，对此类信息的需求也在增长。需要交叉口信息的原因有很多，例如：
          当页面滚动时延迟加载图像或其他内容。
        </mark>
      </p>
      <p>
        实现“无限滚动”网站，在滚动时加载和呈现越来越多的内容，以便用户不必翻阅页面。报告广告的可见性以计算广告收入。
        <mark>根据用户是否会看到结果来决定是否执行任务或动画过程。</mark>
      </p>
      <p>
        过去实现相交检测涉及事件处理程序和循环调用方法，例如Element.getBoundingClientRect()为每个受影响的元素构建所需的信息。由于所有这些代码都在主线程上运行，
        <mark
          >考虑一个使用无限滚动的网页。其中每个都有自己的相交检测例程，全部在主线程上运行。该网站的作者可能甚至没有意识到这种情况正在发生，。</mark
        >
      </p>
      <p>
        因此即使其中之一也可能会导致性能问题。当网站加载这些测试时，事情可能会变得非常丑陋。它使用供应商提供的库来管理在整个页面中定期放置的广告，到处都有动画图形，并使用绘制通知框等的自定义库。
        <mark
          >因为他们可能对他们正在使用的两个库的内部工作原理知之甚少。当用户滚动页面时，这些相交检测例程在滚动处理代码期间不断触发，导致用户对浏览器、网站及其计算机感到沮丧</mark
        >
      </p>
      <p>
        允许代码注册一个回调函数，每当特定元素进入或退出与另一个元素（或视口）的交集时，或者当两个元素之间的交集发生指定量的变化时，就会执行该回调函数。这样，站点不再需要在主线程上执行任何操作来监视这种元素交叉点，并且浏览器可以根据需要自由优化交叉点的管理。
        无法告诉您一件事：<mark
          >重叠的像素的确切数量或具体是哪些像素；然而，它涵盖了更常见的用例“如果它们在N %
          左右相交，我需要做一些事情。” 路口观察器概念和用法 Intersection Observer API</mark
        >
      </p>
      <p>
        通常，您需要观察与目标元素最近的可滚动祖先相关的交集变化，或者，如果目标元素不是可滚动元素的后代，则需要观察设备视口的交集变化。要观察相对于设备视口的相交，请指定nullforroot选项。继续阅读有关交叉口观察器选项的更详细说明。
        <mark
          >无论您使用视口还是其他元素作为根，API的工作方式都是相同的，每当目标元素的可见性发生变化时，API
          都会执行您提供的回调函数，以便它与根元素交叉所需的交集量。</mark
        >
      </p>
      <p>
        目标元素与其根元素的交集程度称为交集比。这是目标元素的百分比表示，其可见值介于 0.0 和 1.0
        之间。
        <mark
          >创建交叉口观察者通过调用其构造函数并向其传递一个回调函数来创建相交观察器，该回调函数将在沿一个方向或另一个方向跨越阈值时运行：</mark
        >
      </p>
    </div>
  </body>
</html>

<script>
  const observer = new IntersectionObserver((entries, observerTarget) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.className = 'animate'
        observerTarget.unobserve(entry.target)
      }
    })
  })

  const marks = document.querySelectorAll('mark')
  marks.forEach(mark => {
    observer.observe(mark)
  })
</script>
